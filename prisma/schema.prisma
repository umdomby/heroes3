// npx prisma migrate dev --name init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model User {
  id                Int                    @id @default(autoincrement())
  fullName          String
  email             String                 @unique
  provider          String?
  providerId        String?
  password          String
  role              UserRole               @default(USER)
  img               String?
  points            Float                  @default(1000) // баллы пользователя
  p2pPlus           Int?                   @default(0)
  p2pMinus          Int?                   @default(0)
  contact           Json? // поле для хранения контактных данных
  loginHistory      Json? // поле для хранения истории входов
  betsCreated       Bet[]                  @relation("BetsCreated")
  betsCLOSEDCreated BetCLOSED[]            @relation("BetsCLOSEDCreated")
  betsPlaced        BetParticipant[]
  betsCLOSEDPlaced  BetParticipantCLOSED[]
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
}

model PageP2P {
  id        Int      @id @default(autoincrement())
  user1     Int
  user2     Int
  chatP2P   Json?
  points    Float
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OrderP2P {
  id        Int      @id @default(autoincrement())
  user1     Int
  user2     Int
  points    Float
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ContactDataEnum {
  id   Int    @id @default(autoincrement())
  name String @unique
}

model Bet {
  id              Int              @id @default(autoincrement())
  player1         Player           @relation(name: "Player1Bets", fields: [player1Id], references: [id]) // ставки на игрока 1
  player1Id       Int
  player2         Player           @relation(name: "Player2Bets", fields: [player2Id], references: [id]) // ставки на игрока 2
  player2Id       Int
  initBetPlayer1  Float // инициализация ставок на игрока 1
  initBetPlayer2  Float // инициализация ставок на игрока 2
  totalBetPlayer1 Float // Сумма ставок на игрока 1
  totalBetPlayer2 Float // Сумма ставок на игрока 2
  oddsBetPlayer1  Float // разница ставок перекрытия на игрока 1
  oddsBetPlayer2  Float // разница ставок перекрытия на игрока 2
  maxBetPlayer1   Float // Максимальная сумма ставок на игрока 1
  maxBetPlayer2   Float // Максимальная сумма ставок на игрока 2
  currentOdds1    Float // Текущий коэффициент для игрока 1
  currentOdds2    Float // Текущий коэффициент для игрока 2
  totalBetAmount  Float            @default(0) // сумма всех ставок.
  creator         User             @relation("BetsCreated", fields: [creatorId], references: [id]) // создатель события
  creatorId       Int
  status          BetStatus        @default(OPEN) // если статус = CLOSED то ставка закрыта, и перемещается в model BetCLOSED
  participants    BetParticipant[]
  categoryId      Int?
  category        Category?        @relation(fields: [categoryId], references: [id])
  productId       Int?
  product         Product?         @relation(fields: [productId], references: [id])
  productItemId   Int?
  productItem     ProductItem?     @relation(fields: [productItemId], references: [id])
  winnerId        Int? // кто победил PLAYER1 или PLAYER2
  margin          Float? // сумма маржи model BetParticipant margin
  marginOverlap   Float? // возвращенная маржа пользователю от перекрытия ставки, та часть маржи которая не перекрыта
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
}

model BetParticipant {
  id            Int          @id @default(autoincrement())
  betId         Int
  bet           Bet          @relation(fields: [betId], references: [id])
  userId        Int // пользователь который ставит ставку
  user          User         @relation(fields: [userId], references: [id])
  amount        Float // ставка пользователя
  overlap       Float // на какую сумму перекрыто
  odds          Float // Коэффициент ставки
  profit        Float // Выигрыш или частичный выигрыш, в зависимости от перекрытия ставки "overlap Float"
  player        PlayerChoice // выбранный игрок в событии
  margin        Float // маржа пользователя
  marginOverlap Float // если ставка перекрыта не полностью, это возврат пользователю неперекрытой маржи
  isCovered     Boolean      @default(false) // Перекрыта ли ставка
  isWinner      Boolean      @default(false) // Победила ли ставка
  createdAt     DateTime     @default(now())
}

// закрытые ставки, после закрытия ставки model Bet переносится в model BetCLOSED
model BetCLOSED {
  id                 Int                    @id @default(autoincrement())
  participantsCLOSED BetParticipantCLOSED[] @relation("BetCLOSEDParticipants") // Обратная связь
  player1            Player                 @relation(name: "Player1BetsCLOSED", fields: [player1Id], references: [id])
  player1Id          Int
  player2            Player                 @relation(name: "Player2BetsCLOSED", fields: [player2Id], references: [id])
  player2Id          Int
  initBetPlayer1     Float // Инициализация ставок на игрока 1
  initBetPlayer2     Float // Инициализация ставок на игрока 2
  totalBetPlayer1    Float // Сумма ставок на игрока 1
  totalBetPlayer2    Float // Сумма ставок на игрока 2
  oddsBetPlayer1     Float // разница ставок перекрытия на игрока 1
  oddsBetPlayer2     Float // разница ставок перекрытия на игрока 2
  maxBetPlayer1      Float // Максимальная сумма ставок на игрока 1
  maxBetPlayer2      Float // Максимальная сумма ставок на игрока 2
  currentOdds1       Float // Текущий коэффициент для игрока 1
  currentOdds2       Float // Текущий коэффициент для игрока 2
  totalBetAmount     Float                  @default(0) // Общая сумма ставок
  creator            User                   @relation("BetsCLOSEDCreated", fields: [creatorId], references: [id])
  creatorId          Int
  status             BetStatus              @default(CLOSED) // Статус ставки
  categoryId         Int?
  category           Category?              @relation(fields: [categoryId], references: [id])
  productId          Int?
  product            Product?               @relation(fields: [productId], references: [id])
  productItemId      Int?
  productItem        ProductItem?           @relation(fields: [productItemId], references: [id])
  winnerId           Int? // ID победителя (без связи)
  margin             Float? // вся маржа события
  marginOverlap      Float? // возвращенная маржа пользователю от перекрытия ставки, та часть маржи которая не перекрыта
  createdAt          DateTime               @default(now()) // Дата создания
  updatedAt          DateTime               @updatedAt // Дата обновления
}

// закрыте ставки, после закрытия ставки model BetParticipant переносится в model BetParticipantCLOSED
model BetParticipantCLOSED {
  id            Int          @id @default(autoincrement())
  betCLOSEDId   Int
  betCLOSED     BetCLOSED    @relation("BetCLOSEDParticipants", fields: [betCLOSEDId], references: [id]) // Обратная связь
  userId        Int
  user          User         @relation(fields: [userId], references: [id])
  amount        Float // ставка пользователя
  overlap       Float // на какую сумму перекрыто
  odds          Float // Коэффициент ставки
  profit        Float // Выигрыш или частичный выигрыш, в зависимости от перекрытия ставки "overlap Float"
  player        PlayerChoice // выбранный игрок в событии
  margin        Float // маржа пользователя
  marginOverlap Float // если ставка перекрыта не полностью, это возврат части неперекрытой маржи
  isCovered     Boolean      @default(false) // Перекрыта ли ставка
  isWinner      Boolean      @default(false) // Победила ли ставка
  createdAt     DateTime     @default(now())
}

model GlobalData {
  id             Int      @id @default(autoincrement())
  usersPlay      Int // Количество пользователей, участвующих в открытых ставках
  pointsBet      Float // Общая сумма ставок в открытых ставках
  users          Int // Количество зарегистрированных пользователей
  pointsStart    Float // Количество зарегистрированных пользователей * 1000 free
  pointsAllUsers Float // Сумма баллов у пользователей  pointsAllStart - pointsAllUsers = pointsSystem
  pointsAllStart Float?   @default(1000000) // start constantpoints нигде не используется.
  pointsPay      Float? // сколько баллов куплено
  margin         Float? // сумма маржи model Bet margin
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Player {
  id                Int         @id @default(autoincrement())
  name              String      @unique
  player1Bets       Bet[]       @relation(name: "Player1Bets") // Relation for bets as player 1
  player2Bets       Bet[]       @relation(name: "Player2Bets") // Relation for bets as player 2
  player1BetsCLOSED BetCLOSED[] @relation(name: "Player1BetsCLOSED") // Relation for bets as player 1
  player2BetsCLOSED BetCLOSED[] @relation(name: "Player2BetsCLOSED") // Relation for bets as player 2
}

model Category {
  id         Int         @id @default(autoincrement())
  name       String      @unique
  products   Product[]
  bets       Bet[]
  betsCLOSED BetCLOSED[]
}

model Product {
  id           Int           @id @default(autoincrement())
  name         String        @unique
  categoryId   Int
  category     Category      @relation(fields: [categoryId], references: [id])
  productItems ProductItem[]
  bets         Bet[]
  betsCLOSED   BetCLOSED[]
}

model ProductItem {
  id         Int         @id @default(autoincrement())
  name       String      @unique
  productId  Int
  product    Product     @relation(fields: [productId], references: [id])
  bets       Bet[]
  betsCLOSED BetCLOSED[]
}

enum BetStatus {
  OPEN
  CLOSED
  PENDING
}

enum UserRole {
  USER
  ADMIN
}

enum PlayerChoice {
  PLAYER1
  PLAYER2
}
